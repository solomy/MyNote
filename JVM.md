# JVM

### 内存区域

线程私有：**jvm栈、本地方法栈、程序计数器**

线程共享：**堆区、方法区**

<img src="img\image-20200824160546020.png" alt="image-20200824160546020" style="zoom:80%;" />

1. **jvm栈**
   - 每个方法会创建一个栈帧，包含**局部变量表、操作数栈、动态链接、方法出口**
   - 一个方法从调用到执行结束就是**栈帧的入栈与出栈**
2. **本地方法栈**：同jvm栈，执行的是java的方法
3. **程序计数器**：当前线程的字节码行号指示器
4. **堆区**：存放对象实例
   - 新生代：一个eden区、两个survivor区
   - 老年代
5. **方法区**：存储**类信息、常量、静态常量、编译后的代码**

### 内存溢出、内存泄漏

1. **内存溢出**：
   - 代码检查，降低对象的生命周期
   - -Xmx -Xms，调大堆的内存大小
2. **内存泄漏**：GC回收失败
   - 查看快照，使用Java VisualVm工具，查看泄漏对象与root的关联

### 类加载过程

1. **加载**：查找并加载二进制数据，在堆区/方法区创建一个class对象，做为反射入口

   - 缓存机制：先去缓存区看看

   - 全盘负责：class的依赖的也加载
   - 双亲委派：类加载器将请求发给父类加载器，当父类加载不了，最后自己再加载（保证class唯一性，保证安全）

2. **连接**：

   1. 验证：文件格式验证、元数据验证、字节码验证、符号引用验证
   2. 准备：静态变量分配内存（在方法区）
   3. 解析：符号引用转为直接地址

3. **初始化**：静态变量初始化

4. **使用**：new对象

### 垃圾回收

1. ##### 对象存活判断：

   1. 引用计数：
   2. 可达性分析：root（jvm栈引用的对象、方法区引用的对象）

2. ##### GC算法：

   1. **标记清除**：从root开始扫描并标记（产生内存碎片）
   2. **复制**：标记后进行复制到另外一个空间（需要双倍空间）
   3. **标记整理**：标记后整理，即移动对象（需要移动对象的成本）
   4. **分代回收**

3. #### 垃圾收集器：

   1. **Serial**（复制 新生代）

   2. **ParNew**（复制 新生代）

   3. **Parallel Scavenge**（复制 新生代）

   4. **Serial Old**（标记整理 老年代）

   5. **Paraller Old**（标记整理 老年代）

   6. **CMS**：最短停顿、并发收集 （标记清除 老年代）

      1. 初始标记：GC root 直达（stop the world）
      2. 并发标记：三色标记
      3. 重新标记：增量更新
      4. 并发清除

   7. **G1**：无空间碎片、可预测停顿（标记整理 新生代+老年代）

      将堆划为大小相等的Region，（Eden/Survivor/Old/Humongous）优先回收价值大的Region

      1. 初始标记：GC root 直达（stop the world）

      2. 并发标记：三色标记
      3. 重新标记：使用快照日志保证
      4. 筛选回收：时间可控，分优先级回收

   #### 4.三色标记算法

   1. 首先创建三个集合：白、灰、黑。
   2. 将所有对象放入白色集合中。
   3. 然后从根节点开始遍历所有对象（注意这里并不**递归遍历**），把遍历到的对象从白色集合放入灰色集合。
   4. 之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合
   5. 重复 4 直到灰色中无任何对象
   6. 通过write-barrier检测对象有变化，重复以上操作
   7. 收集所有白色对象（垃圾）