### 数据结构

1. ##### 平衡树,排序树,B树,B+树,R树,红黑树

   1. **平衡树**：

      - 左右子树高度差不超过1；左右子树也是一颗平衡二叉树；平衡二叉树不是二叉搜索树，但反之不是；
      - 包含AVL、红黑树、替罪羊树、Treap、伸展树等
      - 作用：提高搜索效率

   2. **[红黑树](https://juejin.im/entry/6844903454767317005)**:

      定义：

      - 每个结点非黑即红
      - 根节点、叶子节点为黑
      - 红节点的子节点为黑
      - <u>从一个节点到其子孙节点所有路径上的黑节点数目相同</u>

      特性：

      - 弱平衡树，左右高度差不大于一倍
      - 查、插、删都为log(n)  || 主要存储有序的数据
      - 应用：Linux进程调度、HashMap1.8、TreeMap、C++中的map和set、epoll（用红黑树管理事件块）、nginx（用红黑树管理timer）

   3. B树

      定义:

      - 也称B-树, 多路平衡查找树，阶数m为子节点数
      - 每个节点最多有m-1个关键字
      - 非根节点最少有m/2 -1 个关键字
      
      
      解释：
      
      - 每个节点存储关键字（key）和对应的数据（data）和子节点的指针
    - 插入删除：按照[m/2-1,m-1]原则拆分或合并节点，叶子节点插入
   
  4. B+树
     
     特点：
     
      - 能够保持插入查找的<u>稳定有序</u>
     - 与B树最大不同，内部节点(索引节点)不保存数据，只保存key。
       
     
     Mysql为什么选择B+：
     
      - B+树内部节点只存储key，占用空间小，每次IO可以观看更多的数据
      - 叶子节点相连，符合磁盘顺序读取
      - 支持范围查询
   
2. 生成树

   - n节点无向完全图可生成 n^(n-2)个生成树

   - 所有生成树包含边数与节点数相同

   - 在生成树中添加一条边就会构成环

   - 最小生成树：生成树中边权值和最小；kuskar算法和Prim算法

     

### 算法

1. ##### 排序

   | 排序方法 | 时间复杂度(平均) | 时间复杂度(最坏) | 时间复杂度(最好) | 空间复杂度 | 稳定性 |
   | -------- | ---------------- | ---------------- | ---------------- | ---------- | ------ |
   | 插入排序 | O(n2)            | O(n2)            | O(n)             | O(1)       | 稳定   |
   | 希尔排序 | O(nlog2n)        | O(n2)            | O(n1.3)          | O(1)       | 不稳定 |
   | 选择排序 | O(n2)            | O(n2)            | O(n2)            | O(1)       | 不稳定 |
   | 堆排序   | O(nlog2n)        | O(nlog2n)        | O(nlog2n)        | O(1)       | 不稳定 |
   | 冒泡排序 | O(n2)            | O(n2)            | O(n)             | O(1)       | 稳定   |
   | 快速排序 | O(nlog2n)        | O(n2)            | O(nlog2n)        | O(nlog2n)  | 不稳定 |
   | 归并排序 | O(nlog2n)        | O(nlog2n)        | O(nlog2n)        | O(n)       | 稳定   |
   | 基数排序 | O(d(n+r))        | O(d(n+r))        | O(d(n+r))        | O(n+r)     | 稳定   |

   

2. ##### 一致性hash

   - 形成一个环，顺时针选择最近的环上节点
   - 为了解决不均匀问题，每个服务器采用虚拟节点（有多个）

3. ##### 哈希冲突

   - 拉链法：用链表接上
   - 开发地址：向下走
   - rehash：用另外一个hash函数计算

### 操作系统

1. ##### 虚拟内存

   简介：

   - 作为虚拟地址和物理地址之间的映射；
   - 每个进程都可以有从0开始的地址空间；
   - 虚拟内存可以做到连续交由操作系统完成内存碎片合并；
   - 解决内存有限问题

   分页

   - 虚拟地址=页号+偏移，
   - 由MMU维护页表作为虚拟页框到物理页框的映射

   缺页中断

   - MMU检测到缺页中断，操作系统会进行对内存的页面调度算法

   内存保护

   - 由MMU与页表控制，进程访问不属于它的虚拟内存会发生段错误

   页面置换算法

   - 最佳OPT：理论上的算法：所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。
   - 最近最久没使用LRU：通常用链表实现
   - 先进先出FIFO：会导致缺页率升高
   - 第二次机会：FIFO升级版，增加了一个标志为是否使用
   - 时钟Clock：第二次机会的升级版，使用环形链表+一个指针指向最老的页面

   段页式

   - 地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页
   - 既拥有<u>分段系统的共享和保护</u>，又拥有<u>分页系统的虚拟内存</u>

2. ##### 进程、线程、协程

   - 进程是资源分配的基本单位
   - 线程是CPU调度的基本单位
   - 协程是轻量级线程

   进程上下文：包括分配的内存，数据段，附加段，堆栈段，代码段

   线程上下文：栈和寄存器

   协程上下文：栈和寄存器（很小一般只有几十kb）

**进程切换与线程切换的最主要区别：**<u>进程切换涉及到虚拟地址空间的切换而线程切换则不会</u>。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用TLB(Translation Lookaside Buffer)来缓存页地址，用来加速页表查找。<u>当进程切换后页表也要进行切换，页表切换后TLB就失效了</u>，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。

1. ##### 进程通信IPC

   - 管道：单向，只能在父子进程使用
   - FIFO：命名管道，去除只能在父子进程中使用限制
   - 消息队列：解决FIFO同步阻塞问题
   - 信号量：计数器，用于为多个进程共享数据对象的访问
   - 共享内存：最快的IPC
   - Socket：可以跨机器进程通信

2. ##### 进程同步

   - 临界区：对临界资源访问的代码叫临界区
   - 同步和互斥：互斥：多个进程只有一个能进入临界区
   - 信号量：PV操作 P：请求一个资源 V：释放一个资源
   - 管程：wait()，signal()

3. ##### 进程调度算法

   批处理系统：保证吞吐量和周转时间

   - 先来先服务FCFS：可能会先执行长作业，短作业等待时间过长
   - 短作业优先SJF：长作业可能会被饿死
   - 最短剩余时间优先SRTN：短作业的抢占式版本

   交互式系统：保证快速响应

   - 时间片轮转：按照FCFS原则排成一个队列，每次调度队首执行时间片，时间用完，进程停止并移到队尾
   - 优先级调度：随着时间推移增加等待进程得优先级
   - 多级反馈队列：
     - 时间片轮转+优先级调度
     - 有多个队列，每个的时间片大小不同如1，2，4，8。进程没执行完，会被移到后面的队列。
     - 每个队列优先级不同，只有前面的队列为空，后面的队列才会执行

​	

 

